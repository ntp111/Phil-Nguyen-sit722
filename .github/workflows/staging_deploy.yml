name: Staging - Ephemeral Deploy

on:
  workflow_run:
    workflows: [ "CI - Test, Build & Push (testing)" ]
    types: [ completed ]
  workflow_dispatch:

env:
  AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
  # e.g., s224005289week10acr.azurecr.io
  ACR_LOGIN_SERVER: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
  AKS_CLUSTER_NAME: s224005289week10aks
  AKS_RESOURCE_GROUP: sit722

jobs:
  deploy-staging:
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.head_branch == 'testing')
    runs-on: ubuntu-latest

    outputs:
      NAMESPACE:    ${{ steps.ns.outputs.NAMESPACE }}
      FRONTEND_URL: ${{ steps.collect_urls.outputs.FRONTEND_URL }}
      PRODUCT_URL:  ${{ steps.collect_urls.outputs.PRODUCT_URL }}
      ORDER_URL:    ${{ steps.collect_urls.outputs.ORDER_URL }}
      CUSTOMER_URL: ${{ steps.collect_urls.outputs.CUSTOMER_URL }}

    env:
      # Unique ephemeral namespace per run
      NAMESPACE: staging-${{ github.run_id }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ env.AZURE_CREDENTIALS }}
          enable-AzPSSession: true

      - name: Set Kubernetes context (get AKS credentials)
        run: |
          az aks get-credentials \
            --resource-group "${{ env.AKS_RESOURCE_GROUP }}" \
            --name "${{ env.AKS_CLUSTER_NAME }}" \
            --overwrite-existing

      # Ensure cluster can pull from ACR (idempotent)
      - name: Attach ACR to AKS
        shell: bash
        run: |
          REG_NAME="${ACR_LOGIN_SERVER%%.azurecr.io}"
          if [[ -z "$REG_NAME" || "$REG_NAME" == "$ACR_LOGIN_SERVER" ]]; then
            echo "ERROR: ACR_LOGIN_SERVER must look like <name>.azurecr.io (got: $ACR_LOGIN_SERVER)"
            exit 1
          fi
          az aks update \
            --name "${{ env.AKS_CLUSTER_NAME }}" \
            --resource-group "${{ env.AKS_RESOURCE_GROUP }}" \
            --attach-acr "$REG_NAME"

      - name: Create ephemeral namespace
        id: ns
        run: |
          NS="${{ env.NAMESPACE }}"
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create namespace "$NS"
          echo "NAMESPACE=$NS" >> $GITHUB_OUTPUT

      - name: Deploy infra (ConfigMaps, Secrets, Databases, RabbitMQ)
        run: |
          NS="${{ env.NAMESPACE }}"
          kubectl -n "$NS" apply -f k8s/configmaps.yaml
          kubectl -n "$NS" apply -f k8s/secrets.yaml
          kubectl -n "$NS" apply -f k8s/product-db.yaml
          kubectl -n "$NS" apply -f k8s/order-db.yaml
          kubectl -n "$NS" apply -f k8s/rabbitmq.yaml

      - name: Deploy services (Product, Customer, Order, Frontend)
        run: |
          NS="${{ env.NAMESPACE }}"
          kubectl -n "$NS" apply -f k8s/product-service.yaml
          kubectl -n "$NS" apply -f k8s/customer-service.yaml
          kubectl -n "$NS" apply -f k8s/order-service.yaml
          kubectl -n "$NS" apply -f k8s/frontend.yaml

      # Use :latest to match CI’s push
      - name: Point deployments at latest images
        run: |
          NS="${{ env.NAMESPACE }}"
          ACR="${{ env.ACR_LOGIN_SERVER }}"
          kubectl -n "$NS" set image deploy/product-service   "*=${ACR}/product_service:latest"
          kubectl -n "$NS" set image deploy/customer-service  "*=${ACR}/customer_service:latest"
          kubectl -n "$NS" set image deploy/order-service     "*=${ACR}/order_service:latest"
          kubectl -n "$NS" set image deploy/frontend          "*=${ACR}/frontend:latest"

      - name: Wait for rollouts
        run: |
          NS="${{ env.NAMESPACE }}"
          kubectl -n "$NS" rollout status deploy/product-service --timeout=180s
          kubectl -n "$NS" rollout status deploy/customer-service --timeout=180s
          kubectl -n "$NS" rollout status deploy/order-service --timeout=180s
          kubectl -n "$NS" rollout status deploy/frontend --timeout=180s

      - name: Smoke checks
        run: |
          NS="${{ env.NAMESPACE }}"
          kubectl -n "$NS" get pods -o wide
          kubectl -n "$NS" get svc -o wide

      # === Manual testing support: discover IPs, build URLs, print checklist ===
      - name: Wait for External IPs + collect URLs
        id: collect_urls
        shell: bash
        run: |
          set -e
          NS="${{ env.NAMESPACE }}"
          wait_ip () {
            local svc="$1"
            for i in {1..60}; do
              ip=$(kubectl -n "$NS" get svc "$svc" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
              if [[ -n "$ip" ]]; then echo "$ip"; return 0; fi
              sleep 5
            done
            return 1
          }
          get_port () {
            local svc="$1"
            kubectl -n "$NS" get svc "$svc" -o jsonpath='{.spec.ports[0].port}'
          }

          FRONTEND_IP=$(wait_ip frontend) || { echo "frontend LB IP not assigned"; exit 1; }
          PRODUCT_IP=$(wait_ip product-service) || { echo "product-service LB IP not assigned"; exit 1; }
          ORDER_IP=$(wait_ip order-service) || { echo "order-service LB IP not assigned"; exit 1; }
          CUSTOMER_IP=$(wait_ip customer-service) || { echo "customer-service LB IP not assigned"; exit 1; }

          FRONTEND_PORT=$(get_port frontend)
          PRODUCT_PORT=$(get_port product-service)
          ORDER_PORT=$(get_port order-service)
          CUSTOMER_PORT=$(get_port customer-service)

          FRONTEND_URL="http://${FRONTEND_IP}:${FRONTEND_PORT}"
          PRODUCT_URL="http://${PRODUCT_IP}:${PRODUCT_PORT}"
          ORDER_URL="http://${ORDER_IP}:${ORDER_PORT}"
          CUSTOMER_URL="http://${CUSTOMER_IP}:${CUSTOMER_PORT}"

          echo "FRONTEND_URL=${FRONTEND_URL}" >> $GITHUB_OUTPUT
          echo "PRODUCT_URL=${PRODUCT_URL}"   >> $GITHUB_OUTPUT
          echo "ORDER_URL=${ORDER_URL}"       >> $GITHUB_OUTPUT
          echo "CUSTOMER_URL=${CUSTOMER_URL}" >> $GITHUB_OUTPUT

          {
            echo "## Staging environment (namespace \`${NS}\`)"
            echo ""
            echo "- **Frontend:** ${FRONTEND_URL}"
            echo "- **Product API:** ${PRODUCT_URL}"
            echo "- **Order API:** ${ORDER_URL}"
            echo "- **Customer API:** ${CUSTOMER_URL}"
            echo ""
            echo "### Manual acceptance check"
            echo "- [ ] Frontend loads without console errors"
            echo "- [ ] \`${PRODUCT_URL}/health\` returns 200"
            echo "- [ ] \`${ORDER_URL}/health\` returns 200"
            echo "- [ ] \`${CUSTOMER_URL}/health\` returns 200"
            echo "- [ ] Basic end-to-end flow succeeds"
            echo ""
            echo "_Approve the **manual-verify** job (environment: \`staging-verify\`) to proceed to teardown._"
          } >> $GITHUB_STEP_SUMMARY

  # Manual approval gate (use a protected environment called "staging-verify")
  manual-verify:
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment:
      name: staging-verify   # Configure required reviewers in repo settings → Environments
    steps:
      - name: Show ephemeral URLs
        run: |
          echo "Frontend:  ${{ needs.deploy-staging.outputs.FRONTEND_URL }}"
          echo "Product:   ${{ needs.deploy-staging.outputs.PRODUCT_URL }}"
          echo "Order:     ${{ needs.deploy-staging.outputs.ORDER_URL }}"
          echo "Customer:  ${{ needs.deploy-staging.outputs.CUSTOMER_URL }}"

  # Teardown after approval
  teardown-staging:
    needs: [deploy-staging, manual-verify]
    runs-on: ubuntu-latest
    steps:
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ env.AZURE_CREDENTIALS }}

      - name: Set Kubernetes context (get AKS credentials)
        run: |
          az aks get-credentials \
            --resource-group "${{ env.AKS_RESOURCE_GROUP }}" \
            --name "${{ env.AKS_CLUSTER_NAME }}" \
            --overwrite-existing

      - name: Delete ephemeral namespace
        run: |
          NS="${{ needs.deploy-staging.outputs.NAMESPACE }}"
          kubectl delete namespace "$NS" --ignore-not-found=true

      - name: Azure Logout
        if: always()
        run: az logout
